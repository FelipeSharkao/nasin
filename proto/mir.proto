syntax = "proto2";

package torvo.mir;

message Module {
    required string     name    = 1;
    repeated Global     globals = 2;
    repeated Func       funcs   = 3;
    optional ModuleInit init    = 4;
}

message Func {
    optional Export export = 1;
    repeated Param  params = 2;
    repeated Local  locals = 3;
    repeated Ty     ret    = 4;
    repeated Instr  body   = 5;
}

message Global {
    optional Export export = 1;
    required Ty     ty     = 2;
}

message ModuleInit {
    repeated Local locals = 1;
    repeated Instr body   = 2;
}

message Export {
    required string name = 1;
}

message Param {
    required Ty ty = 1;
}

message Local {
    required Ty ty = 1;
}

message Instr {
    oneof instr {
        LoadGlobal  load_global  = 1;
        StoreGlobal store_global = 2;
        Cons        cons         = 3;
        BinOp       bin_op       = 4;
        Call        call         = 5;
        Value       return       = 6;
    }
}

message LoadGlobal {
    /** The index of the local variable to store the result */
    required uint32 target_idx = 2;
    required uint32 global_idx = 1;
}

message StoreGlobal {
    required uint32 global_idx = 1;
    required Value  value      = 2;
}

message Cons {
    /** The index of the local variable to store the result */
    required uint32 target_idx = 1;
    oneof value {
        /** Any number value. At type checking, it should fail if the number is
          * not representable in the type.
          */
        string number = 2;
    }
}

message BinOp {
    /** The index of the local variable to store the result */
    required uint32    target_idx = 1;
    required BinOpType op         = 2;
    required Value     left       = 3;
    required Value     right      = 4;
}

enum BinOpType {
    ADD = 0;
    SUB = 1;
    MUL = 2;
    DIV = 3;
    MOD = 4;
    POW = 5;
}

message Call {
    /** The index of the local variable to store the result */
    required uint32 target_idx = 1;
    required uint32 func_idx   = 3;
    repeated Value  args       = 4;
}

// Type
message Ty {
    oneof ty {
        /* Unknown type must only be used for the lexer before resolving to the correct type. No
         * code can be generated with an unknown type. It's value is never read.
         */
        // FIXME: merge this and AmbigType into a InferType
        bool      unknown   = 1;
        PrimType  primitive = 2;
        FuncType  func      = 3;
        /* Ambiguous type are a union of possible type, but only one will be used. In may targets,
         * it needs to be resolved to a single type before any code generation.
         */
        AmbigType ambig     = 4;
    }
}

enum PrimType {
    I8    = 0;
    I16   = 1;
    I32   = 2;
    I64   = 3;
    U8    = 4;
    U16   = 5;
    U32   = 6;
    U64   = 7;
    USize = 8;
    F32   = 9;
    F64   = 10;
    Bool  = 11;
    Char  = 12;
}

message FuncType {
    repeated Ty ret  = 1;
    repeated Ty args = 2;
}

message AmbigType {
    repeated Ty types = 1;
}

// Values
message Value {
    oneof value {
        uint32 local  = 1;
        uint32 param  = 2;
    }
}
