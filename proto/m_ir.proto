syntax = "proto2";

package torvo.m_ir;

message Module {
    required string   name   = 1;
    repeated DataDecl data   = 2;
    repeated FnDecl   funcs  = 3;
    optional ModuleInit init = 4;
}

message FnDecl {
    optional Export export = 1;
    repeated Param  params = 2;
    repeated Local  locals = 3;
    repeated Type   ret    = 4;
    repeated Instr  body   = 5;
}

message DataDecl {
    optional Export export = 1;
    required Type   type   = 2;
}

message ModuleInit {
    repeated Local locals = 1;
    repeated Instr body   = 2;
}

message Export {
    required string name = 1;
}

message Param {
    required Type type = 1;
}

message Local {
    required Type type = 1;
}

message Instr {
    oneof instr {
        LoadGlobal  load_global  = 1;
        StoreGlobal store_global = 2;
        Const       const        = 3;
        BinOp       bin_op       = 4;
        FnCall      fn_call      = 5;
        Value       fn_return    = 6;
    }
}

message LoadGlobal {
    /** The index of the local variable to store the result */
    required uint32 target_idx = 2;
    required uint32 global_idx = 1;
}

message StoreGlobal {
    required uint32 global_idx = 1;
    required Value  value      = 2;
}

message Const {
    /** The index of the local variable to store the result */
    required uint32 target_idx = 1;
    oneof value {
        /** Any number value. At type checking, it should fail if the number is
          * not representable in the type.
          */
        string number = 2;
    }
}

message BinOp {
    /** The index of the local variable to store the result */
    required uint32    target_idx = 1;
    required BinOpType op         = 2;
    required Value     left       = 3;
    required Value     right      = 4;
}

enum BinOpType {
    ADD = 0;
    SUB = 1;
    MUL = 2;
    DIV = 3;
    MOD = 4;
    POW = 5;
}

message FnReturn {
    required Value value = 1;
}

message FnCall {
    /** The index of the local variable to store the result */
    required uint32 target_idx = 1;
    required uint32 func_idx   = 3;
    repeated Value  args       = 4;
}

// Type
message Type {
    oneof type {
        /* Unknown type must only be used for the lexer before resolving to the correct type. No
         * code can be generated with an unknown type. It's value is never read.
         */
        // FIXME: merge this and AmbigType into a InferType
        bool      unknown   = 1;
        PrimType  primitive = 2;
        FnType    fn        = 3;
        /* Ambiguous type are a union of possible type, but only one will be used. In may targets,
         * it needs to be resolved to a single type before any code generation.
         */
        AmbigType ambig     = 4;
    }
}

enum PrimType {
    I8    = 0;
    I16   = 1;
    I32   = 2;
    I64   = 3;
    U8    = 4;
    U16   = 5;
    U32   = 6;
    U64   = 7;
    USize = 8;
    F32   = 9;
    F64   = 10;
    Bool  = 11;
    Char  = 12;
}

message FnType {
    repeated Type ret  = 1;
    repeated Type args = 2;
}

message AmbigType {
    repeated Type types = 1;
}

// Values
message Value {
    oneof value {
        uint32 local  = 1;
        uint32 param  = 2;
    }
}
